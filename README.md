# Learning OCaml

This repo is an attempt to learn a new language when agents already write most of my production code.

For a personal project, I wanted to build a compiler-like program and thought that OCaml would be a good fit.

So instead of going through a tutorial, I decided that it would be nice to have a personalized course that starts from the basics and continues to relevant topics skipping stuff I won't need.


Steps to reproduce:
1. With ChatGPT generate something like [this](.cursor/rules/00-initial.mdc)
2. With Cursor agent or whatever implement the repo using the tech spec. Go step by step and often validate, make it solve it's own problems before considering that it's done.
3. Enjoy

## Everything below is generated by AI

# üéì Learn OCaml: A Personalized Journey to Compiler Development

Welcome to your personal OCaml learning repository! This is a carefully crafted educational course designed to take you from OCaml basics to building a compiler that targets WebAssembly.

## üó∫Ô∏è Learning Path

This course is structured in 5 modules, each building on the previous one:

### üìò Module A ‚Äî OCaml Basics and Idioms

Master the fundamentals of OCaml and functional programming patterns.

- **Task 1: Hello, World! + Build and I/O
  - `let` bindings and immutability
  - Basic I/O operations
  - Building with `dune`
  
- **Task 2: Functions and Recursion**
  - `let rec` and recursive functions
  - Tail recursion and accumulators
  - Performance implications
  
- **Task 3: Pattern Matching and Lists**
  - The `match` expression
  - Implementing `map`, `filter`, `fold_left`
  - The pipeline operator `|>`
  
- **Task 4: ADT and Interfaces**
  - Algebraic Data Types (variants)
  - Binary Search Tree implementation
  - Module signatures (`.mli` files)
  
- **Task 5: Option/Result and Error Handling**
  - `option` and `result` types
  - Idiomatic error handling without exceptions
  - Pattern matching on errors
  
- **Task 6: Modules and Functors**
  - Module system
  - Functors for parameterized modules
  - Building a `Rational` number library

### üå≥ Module B ‚Äî AST, Parsing, Pretty-Printing

Learn to work with Abstract Syntax Trees - the foundation of compilers.

- **Task 7: Arithmetic AST + Pretty-Print**
  - Defining expression types
  - Tree traversal and evaluation
  - Pretty-printing with the `Format` module
  
- **Task 8: Parser (Recursive Descent)**
  - Parsing expressions without dependencies
  - Handling operator precedence
  - Error reporting with `result`
  
- **Task 9: Variables and `let ... in ...`**
  - Extending the AST with bindings
  - Environment-based evaluation
  - Variable scoping

### üîÑ Module C ‚Äî AST Transformations

Master the art of tree rewriting - a core compiler skill.

- **Task 10: Constant Folding and Algebraic Simplifications**
  - Compile-time optimization
  - Tree rewriting patterns
  - Preserving semantics
  
- **Task 11: Alpha-Renaming and Shadow Elimination**
  - Name hygiene
  - Fresh variable generation
  - Scope management

### üñ•Ô∏è Module D ‚Äî Intermediate VM ‚Üí Bridge to WASM

Transition from high-level ASTs to executable code.

- **Task 12: Toy Stack Machine**
  - Stack-based execution model
  - Compiling to bytecode
  - Interpreting instructions

### üöÄ Module E ‚Äî Ecosystem and Quality

Experience real-world OCaml development practices.

- **Task 13: Ecosystem I: Dependencies, Tests, Formatting**
  - Managing dependencies with `opam`
  - Property-based testing with `qcheck`
  - Code formatting with `ocamlformat`
  
- **Task 14: Real VM: Compiler to WebAssembly**
  - Generating `.wat` (WebAssembly Text format)
  - Targeting a real VM
  - Running and testing compiled code

## üéØ Learning Philosophy

This repository follows a unique educational approach:

1. **Theory First**: Every task starts with self-contained explanations of OCaml concepts
2. **Learn by Doing**: Implementation files are empty - you must write the code yourself
3. **Immediate Feedback**: Comprehensive tests verify your solutions
4. **Cross-Language Analogies**: Concepts are explained with comparisons to C, Python, Rust, and Haskell
5. **Incremental Progress**: Each task builds naturally on previous ones

## üöÄ Getting Started

### Prerequisites

- OCaml (version 4.14+ recommended)
- opam (OCaml package manager)
- dune (OCaml build system)

### Installation

```bash
# Install OCaml via opam
opam init
opam switch create 4.14.0
eval $(opam env)

# Install dune
opam install dune

# Install alcotest for testing
opam install alcotest
```

### Working on a Task

1. Navigate to the task directory (e.g., `cd task01_hello_world`)
2. Read the `README.md` thoroughly - it contains all the theory you need
3. Implement your solution in the appropriate `.ml` file
4. Build: `dune build`
5. Run: `dune exec <task_name>`
6. Test: `dune test`

## üìö Resources

- [OCaml Official Documentation](https://ocaml.org/docs)
- [Real World OCaml](https://dev.realworldocaml.org/)
- [Dune Documentation](https://dune.readthedocs.io/)

## üéì Why This Course?

In the era of AI, this repository represents a different approach to learning: **personalized education that challenges you to think and implement**, rather than just consuming ready-made solutions. Every task is designed to teach you something new while building toward the ultimate goal of writing a compiler.

By the end of this journey, you'll not only know OCaml - you'll understand how to build language tools from the ground up.
